
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pcp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">pcp/errors.go (83.3%)</option>
				
				<option value="file1">pcp/main.go (52.2%)</option>
				
				<option value="file2">pcp/parser.go (89.4%)</option>
				
				<option value="file3">pcp/processor.go (85.1%)</option>
				
				<option value="file4">pcp/types.go (91.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import "fmt"

var (
        ErrOperationEmpty    = fmt.Errorf("operation must specify exactly one of: file, prompt, command, text")
        ErrOperationMultiple = fmt.Errorf("operation must specify exactly one of: file, prompt, command, text")
)

type ErrInvalidYAML struct {
        File string
        Err  error
}

func (e ErrInvalidYAML) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("invalid YAML in file %s: %v", e.File, e.Err)
}</span>

type ErrFileNotFound struct {
        File string
}

func (e ErrFileNotFound) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("file not found: %s", e.File)
}</span>

type ErrBinaryFile struct {
        File string
}

func (e ErrBinaryFile) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("cannot process binary file: %s", e.File)
}</span>

type ErrCircularReference struct {
        File string
        Path []string
}

func (e ErrCircularReference) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("circular reference detected in file %s (reference path: %v)", e.File, e.Path)
}</span>

type ErrCommandFailed struct {
        Command string
        Err     error
}

func (e ErrCommandFailed) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("command execution failed: %s (%v)", e.Command, e.Err)
}</span>

type ErrWordLimitExceeded struct {
        Current int
        Limit   int
}

func (e ErrWordLimitExceeded) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("compiled output (%d words) exceeds maximum word limit (%d words)", e.Current, e.Limit)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "strings"
)

func main() <span class="cov0" title="0">{
        var (
                promptFile     = flag.String("f", "", "Path to YAML prompt file (required)")
                outputFile     = flag.String("o", "", "Output file path (default: stdout)")
                maxWords       = flag.Int("max-words", 128000, "Maximum words in compiled output")
                delimiterStyle = flag.String("delimiter-style", "xml", "Delimiter style: xml, minimal, none, full")
                help           = flag.Bool("h", false, "Show help message")
                helpLong       = flag.Bool("help", false, "Show help message")
        )

        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, `pcp: Prompt Composition Processor

Usage: pcp -f &lt;prompt-file&gt; [-o &lt;output-file&gt;] [-max-words &lt;limit&gt;] [-delimiter-style &lt;style&gt;] [-h]

Compiles content from multiple sources into a single text output for AI agents.

Flags:
  -f string
        Path to YAML prompt file (required)
  -o string
        Output file path (default: stdout)
  -max-words int
        Maximum words in compiled output (default: 128000)
  -delimiter-style string
        Delimiter style: xml, minimal, none, full (default: xml)
  -h, -help
        Show this help message

Important: All errors are written to STDERR to ensure safe piping to agents.

Usage Patterns:
  RECOMMENDED: Use file output for reliable agent workflows
    pcp -f prompt.yml -o context.txt &amp;&amp; agent &lt; context.txt
  
  AVOID: Command substitution with piping (agent runs even if pcp fails)
    $(pcp -f prompt.yml) | agent

Prompt File Format:
  - prompt:
      - file: "relative/path/to/file.txt"
      - prompt: "nested-prompt.yml"
      - command: "ls -la"
      - text: "Literal text content"

Text Field Special Characters:
  Multiline text using YAML literal block scalar:
  - text: |
      This is line one
      This is line two with a tab:        &lt;tab here&gt;
      Line three
  
  Escaped characters in quoted strings:
  - text: "Line with\nnewline and\ttab"
  
  Raw strings with minimal escaping:
  - text: &gt;
      This text will be folded
      but preserves paragraph breaks
`)
        }</span>

        <span class="cov0" title="0">flag.Parse()

        if *help || *helpLong </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">if *promptFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: -f flag is required\n")
                flag.Usage()
                os.Exit(1)
        }</span>

        // Validate delimiter style
        <span class="cov0" title="0">validStyles := map[string]bool{
                "xml":     true,
                "minimal": true,
                "none":    true,
                "full":    true,
        }
        if !validStyles[*delimiterStyle] </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: invalid delimiter style '%s'. Must be one of: xml, minimal, none, full\n", *delimiterStyle)
                flag.Usage()
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err := processPromptFile(*promptFile, *outputFile, *maxWords, *delimiterStyle); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

func processPromptFile(promptFile, outputFile string, maxWords int, delimiterStyle string) error <span class="cov8" title="1">{
        ctx := NewProcessingContext(promptFile, maxWords, delimiterStyle)

        if err := validatePromptFileStructure(promptFile, ctx); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">ctx = NewProcessingContext(promptFile, maxWords, delimiterStyle)

        pf, err := parsePromptFile(promptFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var compiledContent CompiledContent
        for _, op := range pf.Prompt </span><span class="cov8" title="1">{
                section, err := processOperation(op, ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">compiledContent.Sections = append(compiledContent.Sections, section)</span>
        }

        <span class="cov8" title="1">output, err := compileOutput(compiledContent, delimiterStyle)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if outputFile == "" </span><span class="cov8" title="1">{
                fmt.Print(output)
        }</span> else<span class="cov8" title="1"> {
                if err := os.WriteFile(outputFile, []byte(output), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write output file %s: %w", outputFile, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func compileOutput(content CompiledContent, delimiterStyle string) (string, error) <span class="cov8" title="1">{
        var result strings.Builder

        for i, section := range content.Sections </span><span class="cov8" title="1">{
                if i &gt; 0 || len(content.Sections) &gt; 0 </span><span class="cov8" title="1">{
                        result.WriteString(formatSectionHeader(section.Source, delimiterStyle))
                }</span>
                <span class="cov8" title="1">result.WriteString(section.Content)</span>
        }

        <span class="cov8" title="1">return result.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

func parsePromptFile(filePath string) (*PromptFile, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrFileNotFound{File: filePath}
        }</span>

        <span class="cov8" title="1">var promptFile PromptFile
        if err := yaml.Unmarshal(data, &amp;promptFile); err != nil </span><span class="cov0" title="0">{
                return nil, ErrInvalidYAML{File: filePath, Err: err}
        }</span>

        <span class="cov8" title="1">if err := validatePromptFile(&amp;promptFile); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("validation failed for %s: %w", filePath, err)
        }</span>

        <span class="cov8" title="1">return &amp;promptFile, nil</span>
}

func validatePromptFile(pf *PromptFile) error <span class="cov8" title="1">{
        if pf.Prompt == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("missing required 'prompt' key")
        }</span>

        <span class="cov8" title="1">for i, op := range pf.Prompt </span><span class="cov8" title="1">{
                if _, err := op.GetType(); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("operation %d: %w", i, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func isBinaryFile(filePath string) bool <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">defer file.Close()

        buffer := make([]byte, 512)
        n, err := file.Read(buffer)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                if buffer[i] == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func validatePromptFileStructure(filePath string, ctx *ProcessingContext) error <span class="cov8" title="1">{
        absPath, _ := filepath.Abs(filePath)

        if ctx.IsVisited(absPath) </span><span class="cov8" title="1">{
                return ErrCircularReference{File: filePath, Path: getVisitedPaths(ctx)}
        }</span>

        <span class="cov8" title="1">ctx.MarkVisited(absPath)
        defer func() </span><span class="cov8" title="1">{
                delete(ctx.visitedFiles, absPath)
        }</span>()

        <span class="cov8" title="1">pf, err := parsePromptFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for _, op := range pf.Prompt </span><span class="cov8" title="1">{
                opType, _ := op.GetType()
                if opType == PromptOp </span><span class="cov8" title="1">{
                        nestedPath := ctx.ResolvePath(op.GetValue())
                        if err := validatePromptFileStructure(nestedPath, ctx); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func getVisitedPaths(ctx *ProcessingContext) []string <span class="cov8" title="1">{
        paths := make([]string, 0, len(ctx.visitedFiles))
        for path := range ctx.visitedFiles </span><span class="cov8" title="1">{
                paths = append(paths, path)
        }</span>
        <span class="cov8" title="1">return paths</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
)

func processOperation(op Operation, ctx *ProcessingContext) (ContentSection, error) <span class="cov8" title="1">{
        opType, err := op.GetType()
        if err != nil </span><span class="cov0" title="0">{
                return ContentSection{}, err
        }</span>

        <span class="cov8" title="1">value := op.GetValue()

        switch opType </span>{
        case FileOp:<span class="cov8" title="1">
                return processFileOperation(value, ctx)</span>
        case PromptOp:<span class="cov8" title="1">
                return processPromptOperation(value, ctx)</span>
        case CommandOp:<span class="cov8" title="1">
                return processCommandOperation(value, ctx)</span>
        case TextOp:<span class="cov8" title="1">
                return processTextOperation(value, ctx)</span>
        default:<span class="cov0" title="0">
                return ContentSection{}, fmt.Errorf("unknown operation type")</span>
        }
}

func processFileOperation(filePath string, ctx *ProcessingContext) (ContentSection, error) <span class="cov8" title="1">{
        resolvedPath := ctx.ResolvePath(filePath)

        if _, err := os.Stat(resolvedPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return ContentSection{}, ErrFileNotFound{File: resolvedPath}
        }</span>

        <span class="cov8" title="1">if isBinaryFile(resolvedPath) </span><span class="cov8" title="1">{
                return ContentSection{}, ErrBinaryFile{File: resolvedPath}
        }</span>

        <span class="cov8" title="1">content, err := os.ReadFile(resolvedPath)
        if err != nil </span><span class="cov0" title="0">{
                return ContentSection{}, fmt.Errorf("failed to read file %s: %w", resolvedPath, err)
        }</span>

        <span class="cov8" title="1">contentStr := string(content)
        wordCount := countWords(contentStr)
        if err := ctx.AddWords(wordCount); err != nil </span><span class="cov0" title="0">{
                return ContentSection{}, err
        }</span>

        <span class="cov8" title="1">return ContentSection{
                Source:  filePath,
                Content: contentStr,
                Type:    FileOp,
        }, nil</span>
}

func processPromptOperation(promptPath string, ctx *ProcessingContext) (ContentSection, error) <span class="cov8" title="1">{
        resolvedPath := ctx.ResolvePath(promptPath)

        if ctx.IsVisited(resolvedPath) </span><span class="cov0" title="0">{
                return ContentSection{}, ErrCircularReference{File: resolvedPath, Path: getVisitedPaths(ctx)}
        }</span>

        <span class="cov8" title="1">pf, err := parsePromptFile(resolvedPath)
        if err != nil </span><span class="cov0" title="0">{
                return ContentSection{}, err
        }</span>

        <span class="cov8" title="1">oldBasePath := ctx.basePath
        ctx.basePath = filepath.Dir(resolvedPath)
        ctx.MarkVisited(resolvedPath)

        var allSections []ContentSection
        for _, op := range pf.Prompt </span><span class="cov8" title="1">{
                section, err := processOperation(op, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return ContentSection{}, err
                }</span>
                <span class="cov8" title="1">allSections = append(allSections, section)</span>
        }

        <span class="cov8" title="1">delete(ctx.visitedFiles, resolvedPath)
        ctx.basePath = oldBasePath

        var combinedContent strings.Builder
        for i, section := range allSections </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        combinedContent.WriteString("\n")
                }</span>
                <span class="cov8" title="1">combinedContent.WriteString(formatSectionHeader(promptPath+"-&gt;"+section.Source, ctx.delimiterStyle))
                combinedContent.WriteString(section.Content)</span>
        }

        <span class="cov8" title="1">wordCount := countWords(combinedContent.String())
        if err := ctx.AddWords(wordCount); err != nil </span><span class="cov0" title="0">{
                return ContentSection{}, err
        }</span>

        <span class="cov8" title="1">return ContentSection{
                Source:  promptPath,
                Content: combinedContent.String(),
                Type:    PromptOp,
        }, nil</span>
}

func processCommandOperation(command string, ctx *ProcessingContext) (ContentSection, error) <span class="cov8" title="1">{
        cmd := exec.Command("sh", "-c", command)
        output, err := cmd.CombinedOutput()

        outputStr := string(output)

        if err != nil </span><span class="cov8" title="1">{
                if cmd.ProcessState != nil &amp;&amp; cmd.ProcessState.ExitCode() == 1 </span><span class="cov8" title="1">{
                        fmt.Fprintf(os.Stderr, "Warning: command '%s' exited with status 1 but continuing processing\n", command)
                }</span> else<span class="cov8" title="1"> {
                        return ContentSection{}, ErrCommandFailed{Command: command, Err: err}
                }</span>
        }

        <span class="cov8" title="1">wordCount := countWords(outputStr)
        if err := ctx.AddWords(wordCount); err != nil </span><span class="cov0" title="0">{
                return ContentSection{}, err
        }</span>

        <span class="cov8" title="1">return ContentSection{
                Source:  command,
                Content: outputStr,
                Type:    CommandOp,
        }, nil</span>
}

func processTextOperation(text string, ctx *ProcessingContext) (ContentSection, error) <span class="cov8" title="1">{
        wordCount := countWords(text)
        if err := ctx.AddWords(wordCount); err != nil </span><span class="cov8" title="1">{
                return ContentSection{}, err
        }</span>

        <span class="cov8" title="1">return ContentSection{
                Source:  "text",
                Content: text,
                Type:    TextOp,
        }, nil</span>
}

func formatSectionHeader(source, delimiterStyle string) string <span class="cov8" title="1">{
        switch delimiterStyle </span>{
        case "xml":<span class="cov8" title="1">
                return fmt.Sprintf("&lt;!-- pcp-source: %s --&gt;\n", source)</span>
        case "minimal":<span class="cov8" title="1">
                return fmt.Sprintf("=== PCP SOURCE: %s ===\n", source)</span>
        case "none":<span class="cov8" title="1">
                return ""</span>
        case "full":<span class="cov8" title="1">
                return fmt.Sprintf("\n----------------------------------\nBEGIN: %s\n----------------------------------\n", source)</span>
        default:<span class="cov0" title="0">
                // Default to xml style for unknown styles
                return fmt.Sprintf("&lt;!-- pcp-source: %s --&gt;\n", source)</span>
        }
}

func countWords(text string) int <span class="cov8" title="1">{
        if text == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return len(strings.Fields(text))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "path/filepath"
)

type OperationType int

const (
        FileOp OperationType = iota
        PromptOp
        CommandOp
        TextOp
)

type PromptFile struct {
        Prompt []Operation `yaml:"prompt"`
}

type Operation struct {
        File    *string `yaml:"file,omitempty"`
        Prompt  *string `yaml:"prompt,omitempty"`
        Command *string `yaml:"command,omitempty"`
        Text    *string `yaml:"text,omitempty"`
}

func (op *Operation) GetType() (OperationType, error) <span class="cov8" title="1">{
        count := 0
        var opType OperationType

        if op.File != nil </span><span class="cov8" title="1">{
                count++
                opType = FileOp
        }</span>
        <span class="cov8" title="1">if op.Prompt != nil </span><span class="cov8" title="1">{
                count++
                opType = PromptOp
        }</span>
        <span class="cov8" title="1">if op.Command != nil </span><span class="cov8" title="1">{
                count++
                opType = CommandOp
        }</span>
        <span class="cov8" title="1">if op.Text != nil </span><span class="cov8" title="1">{
                count++
                opType = TextOp
        }</span>

        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return 0, ErrOperationEmpty
        }</span>
        <span class="cov8" title="1">if count &gt; 1 </span><span class="cov8" title="1">{
                return 0, ErrOperationMultiple
        }</span>

        <span class="cov8" title="1">return opType, nil</span>
}

func (op *Operation) GetValue() string <span class="cov8" title="1">{
        switch </span>{
        case op.File != nil:<span class="cov8" title="1">
                return *op.File</span>
        case op.Prompt != nil:<span class="cov8" title="1">
                return *op.Prompt</span>
        case op.Command != nil:<span class="cov8" title="1">
                return *op.Command</span>
        case op.Text != nil:<span class="cov8" title="1">
                return *op.Text</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

type ContentSection struct {
        Source  string
        Content string
        Type    OperationType
}

type CompiledContent struct {
        Sections []ContentSection
}

type ProcessingContext struct {
        basePath       string
        visitedFiles   map[string]bool
        maxWords       int
        wordCount      int
        delimiterStyle string
}

func NewProcessingContext(basePath string, maxWords int, delimiterStyle string) *ProcessingContext <span class="cov8" title="1">{
        return &amp;ProcessingContext{
                basePath:       filepath.Dir(basePath),
                visitedFiles:   make(map[string]bool),
                maxWords:       maxWords,
                wordCount:      0,
                delimiterStyle: delimiterStyle,
        }
}</span>

func (ctx *ProcessingContext) MarkVisited(path string) <span class="cov8" title="1">{
        absPath, _ := filepath.Abs(path)
        ctx.visitedFiles[absPath] = true
}</span>

func (ctx *ProcessingContext) IsVisited(path string) bool <span class="cov8" title="1">{
        absPath, _ := filepath.Abs(path)
        return ctx.visitedFiles[absPath]
}</span>

func (ctx *ProcessingContext) ResolvePath(path string) string <span class="cov8" title="1">{
        if filepath.IsAbs(path) </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov8" title="1">return filepath.Join(ctx.basePath, path)</span>
}

func (ctx *ProcessingContext) AddWords(count int) error <span class="cov8" title="1">{
        ctx.wordCount += count
        if ctx.wordCount &gt; ctx.maxWords </span><span class="cov8" title="1">{
                return ErrWordLimitExceeded{Current: ctx.wordCount, Limit: ctx.maxWords}
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
